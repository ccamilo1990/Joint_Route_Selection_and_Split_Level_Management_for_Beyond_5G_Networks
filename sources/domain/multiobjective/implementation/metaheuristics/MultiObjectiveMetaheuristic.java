package domain.multiobjective.implementation.metaheuristics;

import domain.multiobjective.MultiObjectiveAlgorithm;
import domain.multiobjective.MultiObjectiveFunction;
import domain.multiobjective.MultiObjectiveSolution;
import domain.problem.ProblemInstance;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 *
 * @author D_mon
 * @param <T>
 */
public abstract class MultiObjectiveMetaheuristic<T extends MultiObjectiveSolution> implements MultiObjectiveAlgorithm<Integer[], Double> {

    /**
     *
     */
    protected Random rand;
    /**
     * The number of iterations.
     */
    protected int numIterations;
    /**
     * The instance of the problem to be solved.
     */
    protected final ProblemInstance instance;
    /**
     * The multi-objective function.
     */
    protected final MultiObjectiveFunction fx;
    /**
     * *
     * The number of non-factible solutions generated by the algorithm.
     */
    protected long numNotValidSolutions;

    /**
     * The best solution found.
     */
    protected T best;
    /**
     * The pareto front.
     */
    protected List<T> front;

    public MultiObjectiveMetaheuristic(ProblemInstance instance, MultiObjectiveFunction fx, Random rand, int numIterations) {
        this.fx = fx;
        this.rand = rand;
        this.instance = instance;
        this.numIterations = numIterations;
        this.front = new ArrayList<>();
    }

    public long getNumNotValidSolutions() {
        return numNotValidSolutions;
    }

    public int getNumIterations() {
        return numIterations;
    }

    /**
     * This function determines if the solution "a" dominates the solution "b".
     *
     * @param a The solution a.
     * @param b The solution b.
     * @return true if solution "a" dominates solution "b". false otherwise.
     */
    protected boolean dominates(T a, T b) {
        boolean noneIsWorst = true, atLeastOneIsBetter = false;
        if (a.getNumberOfObjectives() == b.getNumberOfObjectives()) {
            if (a.getObjectives() != null && b.getObjectives() != null) {
                for (int i = 0; i < a.getNumberOfObjectives(); i++) {
                    if (a.getObjectives()[i].compareTo(b.getObjectives()[i]) < 0) {
                        noneIsWorst = false;
                        break;
                    }
                    if (a.getObjectives()[i].compareTo(b.getObjectives()[i]) > 0) {
                        atLeastOneIsBetter = true;
                    }
                }
            } else {
                throw new NullPointerException();
            }
        } else {
            throw new ArrayIndexOutOfBoundsException("The number of objectives does not match.");
        }
        return noneIsWorst && atLeastOneIsBetter;
    }

    @Override
    public abstract List<MultiObjectiveSolution> run();
}
